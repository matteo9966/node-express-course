const CustomAPIError = require('../errors');
const Product = require('../models/Product');
// const cloudinary = require('cloudinary').v2;
const path = require('path');
const fs = require('fs');
/* * just a util function to check if user owns this product*/
 function checkOwner(userID, productUser){
   if(userID.toString() !== productUser.toString()){
    throw new CustomAPIError.UnauthorizedError('You dont own this product so you cant update it!');
  }
 }
/**/

const createProduct = async (req, res) => {
  const user = req.user;
  const userID = user._id;
  const recieved_Product = req.body;
  recieved_Product.user = userID;
  const product = await Product.create(recieved_Product);


  res.status(201).json(product);
};

//non passa per autenticazione
const getAllProducts = async (req, res) => {
  const products = await Product.find({});

  res.status(201).json(products);
};

//non passa per autenticazione
const getSingleProduct = async (req, res) => {
  const productID = req.params.id;
   const product = await Product.findById(productID).populate('review'); // ho popolato review, una proprietà virtuale
   res.status(200).json(product);
};

const updateProduct = async (req, res) => {
  
  const userId = req.user._id;
  const productId = req.params.id;
  
  const product = await Product.findById(productId);
  
  checkOwner(userId,product.user);
  
  const {_id,user,...fieldToUpdate} = req.body; 

  const updatedProduct = await Product.findByIdAndUpdate(productId,fieldToUpdate,{new:true});
 
  res.status(200).json(updatedProduct);
};

const deleteProduct = async (req, res) => {
  const userId = req.user._id;
  const productId = req.params.id;

  const product = await Product.findById(productId);
  if(!product) throw new Error("product not available")

  checkOwner(userId,product.user);
   
  const response = await product.deleteOne({_id:productId})

  // const response = await Product.deleteOne({_id:productId}) //deleteOne triggera il deleteOne middleware pre  hook, così prima di cancellare il prodotto cancello tutte le review di quel prodotto

  
  res.status(200).json(response);
};

const uploadImage = async (req, res) => {
  const user = req.user;
  const maxlen= 1024 * 1024;

  if (!req.files || Object.keys(req.files).length === 0) {
    return res.status(400).send('No files were uploaded.');
  }
 
  if(!req.files.image.mimetype.toString().startsWith('image')){
    throw new Error("file must be image!")
  }
  
  if(req.files.image.size>maxlen){
    throw new Error("file must be of maximum: "+maxlen+"bytes");
  }

  

   //per ottenere il file mi serve sapere l'attributo name del input form  name="sampleFile" ad esempio

   const image = req.files.image;
   const tempPath = image.tempFilePath;
   
   

 
   const folderForImages = path.join(__dirname,'../public','uploads');
   
   if (!fs.existsSync(folderForImages)){
    fs.mkdirSync(folderForImages, { recursive: true });
}
 
  const imagePath = path.join(folderForImages,image.name);
   
   const result = await image.mv(imagePath );

  //  cloudinary.uploader.upload(tempPath, { tags: 'product_image',folder:'e-commerce-project' })
  //  .then(function (image) {
  //    console.log();
  //    console.log("** File Upload (Promise)");
  //    console.log("* public_id for the uploaded image is generated by Cloudinary's service.");
  //    console.log("* " + image.public_id);
  //    console.log("* " + image.url);
  //  })
  //  .catch(function (err) {
  //    console.log();
  //    console.log("** File Upload (Promise)");
  //    if (err) { console.warn(err); }
  //  });
 


  res.status(200).json({result});
};

module.exports = {
  createProduct,
  getAllProducts,
  getSingleProduct,
  updateProduct,
  deleteProduct,
  uploadImage,
};
